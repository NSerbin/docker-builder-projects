name: Builder - Docker (multi image) + Helm bump

on:
  repository_dispatch:
    types: [builder.build]

  workflow_dispatch:
    inputs:
      repo_name:
        description: "Repo name (must exist in projects.yml)"
        required: true
        type: string
      source_repo:
        description: "ORG/REPO"
        required: true
        type: string
      ref:
        description: "Git ref (branch / tag / sha)"
        required: false
        default: "main"
        type: string

permissions:
  contents: write
  packages: write

# IMPORTANTE: evita doble-run por mismo repo/ref
concurrency:
  group: builder-${{ github.event.client_payload.repo_name || github.event.inputs.repo_name }}-${{ github.event.client_payload.ref || github.event.inputs.ref || 'main' }}
  cancel-in-progress: true

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      repo_name: ${{ steps.cfg.outputs.repo_name }}
      source_repo: ${{ steps.cfg.outputs.source_repo }}
      ref: ${{ steps.cfg.outputs.ref }}

      registry: ${{ steps.cfg.outputs.registry }}
      platforms: ${{ steps.cfg.outputs.platforms }}
      docker_tag: ${{ steps.tag.outputs.docker_tag }}

      matrix_images: ${{ steps.matrix.outputs.matrix_images }}

      helm_enabled: ${{ steps.helm.outputs.helm_enabled }}
      charts_repo: ${{ steps.helm.outputs.charts_repo }}
      charts_ref: ${{ steps.helm.outputs.charts_ref }}
      chart_path: ${{ steps.helm.outputs.chart_path }}
      values_file: ${{ steps.helm.outputs.values_file }}
      update_app_version: ${{ steps.helm.outputs.update_app_version }}
      updates_json: ${{ steps.helm.outputs.updates_json }}

    steps:
      - uses: actions/checkout@v4

      - name: Install yq (pinned)
        run: |
          set -euo pipefail
          YQ_VERSION="v4.45.4"
          sudo wget -qO /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - id: cfg
        name: Load base config
        env:
          REPO_NAME: ${{ github.event.client_payload.repo_name || github.event.inputs.repo_name }}
          SOURCE_REPO: ${{ github.event.client_payload.source_repo || github.event.inputs.source_repo }}
          REF: ${{ github.event.client_payload.ref || github.event.inputs.ref }}
        run: |
          set -euo pipefail

          if [ -z "${REPO_NAME}" ] || [ "${REPO_NAME}" = "null" ]; then
            echo "repo_name is required"
            exit 1
          fi

          if ! yq -e ".projects.${REPO_NAME}" projects.yml >/dev/null; then
            echo "Project ${REPO_NAME} not found in projects.yml"
            exit 1
          fi

          get() {
            local expr="$1"
            local def="$2"
            local out
            out="$(yq -r "$expr" projects.yml 2>/dev/null || true)"
            if [ -z "$out" ] || [ "$out" = "null" ]; then
              echo "$def"
            else
              echo "$out"
            fi
          }

          REGISTRY="$(get ".projects.${REPO_NAME}.docker.registry" "ghcr")"
          PLATFORMS="$(get ".projects.${REPO_NAME}.docker.platforms" "linux/amd64")"

          {
            echo "repo_name=${REPO_NAME}"
            echo "source_repo=${SOURCE_REPO}"
            echo "ref=${REF}"
            echo "registry=${REGISTRY}"
            echo "platforms=${PLATFORMS}"
          } >> "$GITHUB_OUTPUT"

      - id: tag
        name: Compute docker tag
        run: |
          set -euo pipefail
          REF="${{ steps.cfg.outputs.ref }}"

          if echo "$REF" | grep -Eq '^v?[0-9]+\.[0-9]+\.[0-9]+'; then
            TAG="$REF"
          else
            TAG="sha-$(echo "${GITHUB_SHA}" | cut -c1-7)"
          fi

          echo "docker_tag=${TAG}" >> "$GITHUB_OUTPUT"

      - id: matrix
        name: Build images matrix from projects.yml
        env:
          REPO_NAME: ${{ steps.cfg.outputs.repo_name }}
        run: |
          set -euo pipefail

          python - <<'PY' >> "$GITHUB_OUTPUT"
          import json, subprocess, os, sys

          repo = os.environ["REPO_NAME"]

          def yq(expr):
            r = subprocess.run(["yq","-r",expr,"projects.yml"], capture_output=True, text=True)
            out = (r.stdout or "").strip()
            return "" if out in ("", "null") else out

          def get(expr, default=""):
            v = yq(expr)
            return v if v != "" else default

          # multi-image: docker.images.<key>
          keys_raw = yq(f".projects.{repo}.docker.images | keys | .[]")
          keys = [k.strip() for k in keys_raw.splitlines() if k.strip()]

          arr = []
          if keys:
            for k in keys:
              arr.append({
                "key": k,
                "repository_name": get(f".projects.{repo}.docker.images.{k}.image_name", ""),
                "dockerfile_mode": get(f".projects.{repo}.docker.images.{k}.dockerfile.mode", "source"),
                "dockerfile_path": get(f".projects.{repo}.docker.images.{k}.dockerfile.path", "Dockerfile"),
                "build_context": get(f".projects.{repo}.docker.images.{k}.build.context", "."),
              })
          else:
            # legacy single image
            arr.append({
              "key": "default",
              "repository_name": get(f".projects.{repo}.docker.image_name", repo),
              "dockerfile_mode": get(f".projects.{repo}.docker.dockerfile.mode", "source"),
              "dockerfile_path": get(f".projects.{repo}.docker.dockerfile.path", "Dockerfile"),
              "build_context": get(f".projects.{repo}.docker.build.context", "."),
            })

          arr = [x for x in arr if x.get("repository_name")]
          print("matrix_images=" + json.dumps(arr, separators=(",",":")))
          PY

      - id: helm
        name: Load helm config (and updates_json)
        env:
          REPO_NAME: ${{ steps.cfg.outputs.repo_name }}
        run: |
          set -euo pipefail

          bnorm() {
            case "$1" in
              true|True|TRUE|1|yes|YES|on|ON) echo "true" ;;
              *) echo "false" ;;
            esac
          }

          HELM_ENABLED_RAW="$(yq -r ".projects.${REPO_NAME}.helm.enabled // false" projects.yml)"
          HELM_ENABLED="$(bnorm "$HELM_ENABLED_RAW")"

          CHARTS_REPO="$(yq -r ".projects.${REPO_NAME}.helm.charts_repo // \"\"" projects.yml)"
          CHARTS_REF="$(yq -r ".projects.${REPO_NAME}.helm.charts_ref // \"main\"" projects.yml)"
          CHART_PATH="$(yq -r ".projects.${REPO_NAME}.helm.chart_path // \"\"" projects.yml)"
          VALUES_FILE="$(yq -r ".projects.${REPO_NAME}.helm.values_file // \"values.yaml\"" projects.yml)"

          UPDATE_APP_VERSION_RAW="$(yq -r ".projects.${REPO_NAME}.helm.update_app_version // false" projects.yml)"
          UPDATE_APP_VERSION="$(bnorm "$UPDATE_APP_VERSION_RAW")"

          # MUST be one-line JSON
          UPDATES_JSON="$(yq -o=json -I=0 ".projects.${REPO_NAME}.helm.updates // []" projects.yml)"

          {
            echo "helm_enabled=${HELM_ENABLED}"
            echo "charts_repo=${CHARTS_REPO}"
            echo "charts_ref=${CHARTS_REF}"
            echo "chart_path=${CHART_PATH}"
            echo "values_file=${VALUES_FILE}"
            echo "update_app_version=${UPDATE_APP_VERSION}"
            echo "updates_json=${UPDATES_JSON}"
          } >> "$GITHUB_OUTPUT"

  build:
    name: Build images
    needs: prepare
    # si matrix_images está vacío, no corre
    if: ${{ needs.prepare.outputs.matrix_images != '[]' }}
    strategy:
      fail-fast: false
      matrix:
        img: ${{ fromJson(needs.prepare.outputs.matrix_images) }}
    uses: NSerbin/gh-pipelines/.github/workflows/docker-build.yml@main
    with:
      registry: ${{ needs.prepare.outputs.registry }}
      repository-name: ${{ matrix.img.repository_name }}
      docker-tag: ${{ needs.prepare.outputs.docker_tag }}
      docker-architecture: ${{ needs.prepare.outputs.platforms }}
      ghcr-owner: nserbin

      clone-source: true
      source-repo: ${{ needs.prepare.outputs.source_repo }}
      source-ref: ${{ needs.prepare.outputs.ref }}

      dockerfile-mode: ${{ matrix.img.dockerfile_mode }}
      dockerfile-path: ${{ matrix.img.dockerfile_path }}
      build-context: ${{ matrix.img.build_context }}
    secrets: inherit

  update_helm:
    name: Update Helm values (multi paths) + optional appVersion
    needs: [prepare, build]
    if: ${{ needs.prepare.outputs.helm_enabled == 'true' }}
    uses: NSerbin/gh-pipelines/.github/workflows/helm-update-image-tag.yml@main
    with:
      charts_repo: ${{ needs.prepare.outputs.charts_repo }}
      charts_ref: ${{ needs.prepare.outputs.charts_ref }}
      chart_path: ${{ needs.prepare.outputs.chart_path }}
      values_file: ${{ needs.prepare.outputs.values_file }}

      image_tag: ${{ needs.prepare.outputs.docker_tag }}
      updates_json: ${{ needs.prepare.outputs.updates_json }}

      # boolean REAL (evita "Unexpected value 'true'")
      update_app_version: ${{ needs.prepare.outputs.update_app_version == 'true' }}

      commit_message: "chore(${{
        needs.prepare.outputs.repo_name
      }}): bump images"
    secrets: inherit
